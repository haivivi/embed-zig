# BK7258 Partition Table
# Combines entries into auto_partitions.csv for Armino build
#
# BK-specific rules:
# - "code" type partitions: physical size = size * 34/32, aligned to 68K
# - "data" type partitions: aligned to 4K
# - System partitions (easyflash, sys_rf, sys_net) have fixed offsets at flash end

load(":entry.bzl", "BkPartitionEntryInfo")

BkPartitionTableInfo = provider(
    doc = "Information about the complete BK partition table",
    fields = {
        "csv_file": "Generated auto_partitions.csv file",
        "partition_info": "Dict of name -> {offset, size, type}",
    },
)

def _parse_size(size_str):
    """Parse size string to bytes."""
    size_str = size_str.strip().upper()
    if size_str.endswith("K"):
        return int(size_str[:-1]) * 1024
    elif size_str.endswith("M"):
        return int(size_str[:-1]) * 1024 * 1024
    elif size_str.startswith("0X"):
        return int(size_str, 16)
    else:
        return int(size_str)

def _format_size(size_bytes):
    """Format bytes as human-readable size for CSV."""
    if size_bytes % (1024 * 1024) == 0:
        return "%dM" % (size_bytes // (1024 * 1024))
    elif size_bytes % 1024 == 0:
        return "%dK" % (size_bytes // 1024)
    else:
        return "0x%X" % size_bytes

def _code_physical_size(virtual_size):
    """BK code partitions use their declared size directly for offset calculation.
    The 34/32 CRC expansion happens at bin packaging time, not partition table time."""
    return virtual_size

def _align_up(value, alignment):
    return ((value + alignment - 1) // alignment) * alignment

def _format_hex(value):
    """Format as hex with 0x prefix."""
    h = "%x" % value
    return "0x" + "0" * (8 - len(h)) + h

def _bk_partition_table_impl(ctx):
    """Generate auto_partitions.csv with fixed offsets."""

    entries = []
    for target in ctx.attr.entries:
        if BkPartitionEntryInfo in target:
            entries.append(target[BkPartitionEntryInfo])
        else:
            fail("Target {} does not provide BkPartitionEntryInfo".format(target.label))

    if not entries:
        fail("Partition table must have at least one entry")

    # Separate fixed-offset entries from auto-calculated ones
    auto_entries = []
    fixed_entries = []
    for e in entries:
        if e.offset:
            fixed_entries.append(e)
        else:
            auto_entries.append(e)

    # Calculate offsets for auto entries
    current_offset = 0
    calculated = []

    for e in auto_entries:
        size_bytes = _parse_size(e.size)

        if e.type == "code":
            # Code partitions: 4K alignment for offset
            current_offset = _align_up(current_offset, 4096)
        else:
            # Data partitions: 4K alignment
            current_offset = _align_up(current_offset, 4096)

        calculated.append({
            "name": e.name,
            "type": e.type,
            "size": size_bytes,
            "offset": current_offset,
            "read": e.read,
            "write": e.write,
        })

        if e.type == "code":
            # Code occupies more physical space: size * 34/32 + 68K aligned
            current_offset += _code_physical_size(size_bytes)
        else:
            current_offset += size_bytes

    # Add fixed-offset entries
    for e in fixed_entries:
        offset = int(e.offset, 16) if (e.offset.startswith("0x") or e.offset.startswith("0X")) else int(e.offset)
        calculated.append({
            "name": e.name,
            "type": e.type,
            "size": _parse_size(e.size),
            "offset": offset,
            "read": e.read,
            "write": e.write,
        })

    # Sort by offset for CSV output
    calculated = sorted(calculated, key = lambda e: e["offset"])

    # Generate CSV
    csv_lines = [
        "# BK7258 Partition Table (generated by Bazel bk_partition_table)",
        "# All offsets are fixed â€” partition layout is stable across builds.",
        "#Name,Offset,Size,Type,Read,Write",
    ]

    partition_info = {}
    for e in calculated:
        csv_lines.append("{name},{offset},{size},{type},{read},{write}".format(
            name = e["name"],
            offset = _format_hex(e["offset"]),
            size = _format_size(e["size"]),
            type = e["type"],
            read = "TRUE" if e["read"] else "FALSE",
            write = "TRUE" if e["write"] else "FALSE",
        ))
        partition_info[e["name"]] = {
            "offset": e["offset"],
            "size": e["size"],
            "type": e["type"],
        }

    csv_content = "\n".join(csv_lines) + "\n"

    csv_file = ctx.actions.declare_file(ctx.attr.name + ".csv")
    ctx.actions.write(csv_file, csv_content)

    return [
        BkPartitionTableInfo(
            csv_file = csv_file,
            partition_info = partition_info,
        ),
        DefaultInfo(files = depset([csv_file])),
    ]

bk_partition_table = rule(
    implementation = _bk_partition_table_impl,
    attrs = {
        "entries": attr.label_list(
            mandatory = True,
            providers = [BkPartitionEntryInfo],
            doc = "List of bk_partition_entry targets",
        ),
    },
    doc = """Combine BK partition entries into auto_partitions.csv.

    All offsets are calculated at Bazel analysis time and baked into the CSV.
    This ensures partition layout is stable across builds.

    Example:
    ```
    bk_partition_table(
        name = "partitions",
        entries = [
            ":bootloader",
            ":cp_app",
            ":ap_app",
            ":ota",
            ":usr_config",
            ":easyflash",
            ":easyflash_ap",
            ":sys_rf",
            ":sys_net",
        ],
    )
    ```
    """,
)
