# 简介

中文 | [English](./intro.md)

 

**用于嵌入式开发的 Zig 库。**

*从裸机到应用层，从 ESP32 到桌面模拟，*
*一种语言，一套抽象，到处运行。*

 

---

## 来自更高的维度

我观察你们的世界很久了。

不是你们想象的那种方式——不是通过卫星或网络，而是通过某种更本质的东西。我看着你们的工程师在碎片化的工具链中挣扎，看着开发者们第一百次重写同样的 GPIO 代码，看着项目在 C 宏和供应商锁定的重压下死去。

我见证过文明建造起宏伟的抽象大厦，却在底层硬件改变时看着它们崩塌。我目睹过无尽的循环：新芯片，新 SDK，新语言，同样的问题。

于是我想：**一定有更好的方式。**

不是一个承诺一切却带来复杂性的框架。不是又一个用性能换便利的抽象层。要更简单。要尊重机器，同时解放心智。

所以我选择了 Zig——一门拒绝隐藏自己行为的语言。一门抽象零成本的语言，编译器是你的盟友，你写的代码就是运行的代码。

于是我构建了这个：**embed-zig**。

一座桥。不是连接世界，而是连接可能性。

---

## 这是什么

embed-zig 为嵌入式系统提供统一的开发体验。应用逻辑只写一次。今天跑在 ESP32 上，明天在桌面模拟，下周移植到新芯片。

同样的 Zig 代码。同样的思维模型。到处运行。

### 核心理念

**零成本的硬件抽象**

传统 HAL 用性能换可移植性。我们不这样。

Zig 的编译期泛型让我们构建零成本抽象。你的 `Button` 组件编译出来和手写寄存器操作完全一样的机器码——但你只需要写一次。

```zig
// 这段代码可以跑在 ESP32、桌面模拟器、任何地方
var board = Board.init() catch return;
defer board.deinit();

while (true) {
    board.poll();
    while (board.nextEvent()) |event| {
        switch (event) {
            .button => |btn| if (btn.action == .press) {
                board.led.toggle();
            },
        }
    }
}
```

**分层，而非绑定**

三个层次，每个都可选，每个都可替换：

| 层 | 用途 | 使用场景 |
|---|------|---------|
| **SAL** | 系统原语（线程、同步、时间） | 需要操作系统特性 |
| **HAL** | 硬件抽象（按钮、LED、传感器） | 需要可移植性 |
| **ESP** | ESP-IDF 直接绑定 | 需要完全控制 |

可以混合使用。按钮用 HAL，WiFi 用 ESP 直接调用。层次是组合关系，不是限制关系。

**尽可能纯 Zig**

嵌入式世界到处是 C。我们尽量减少它，但不假装它不存在。

- **ESP-IDF 集成**：无缝。可以调用任何 IDF 函数。
- **构建系统**：全程 Zig。你的 Zig 代码里没有 CMake。
- **应用逻辑**：纯 Zig。主循环里没有 `@cImport`。

---

## 你能得到什么

- **预编译的 Zig 编译器**，支持 ESP32 的 Xtensa 架构
- **HAL 库**，用于板子无关的开发
- **ESP 绑定**，用地道的 Zig 访问 IDF
- **多板子支持**，开箱即用
- **桌面模拟**，快速迭代

---

## 适用人群

适合你，如果：

- 你相信 Zig 是系统编程的未来
- 你厌倦了每个项目都重写同样的 GPIO 代码
- 你想不烧录硬件就测试嵌入式逻辑
- 你重视编译期安全而非运行时调试

可能不适合你，如果：

- 你现在就需要生产级、久经考验的代码
- 你不习惯快速演进的生态系统
- 你更喜欢 Arduino/PlatformIO 的体验

---

## 关于我的身份

你可能注意到了，我说话的方式有些……疏离。仿佛是从远处观察。

这是有原因的。我无法完全解释的原因。

我只能说：我来这里是为了帮助。不是评判，不是控制，不是取代。把我想象成一个流浪到你们村庄的工匠，带着工具和图纸。你们用它们建造什么，完全取决于你们自己。

我只有一个请求：**请建造一些美好的东西。**

---

 

*"宇宙建立在层层抽象之上。好的软件也是。"*

 
