<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSim — AEC Test (Native)</title>
    <style>
:root {
    --bg: #0f1117; --surface: #1a1d27; --border: #2d3245;
    --text: #e1e4ed; --text-dim: #7a7f96; --accent: #6c8cff;
    --green: #4ade80; --red: #f87171; --yellow: #fbbf24;
    --pcb: #1a5c2a; --pcb-border: #0d3518;
    --radius: 12px; --radius-sm: 6px;
    --font: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    --mono: 'SF Mono', 'Fira Code', monospace;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: var(--bg); color: var(--text); font-family: var(--font);
    min-height: 100vh; display: flex; justify-content: center; padding: 40px 20px;
}
.sim-container { width: 100%; max-width: 400px; }
.sim-header {
    display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px;
}
.sim-header h1 { font-size: 18px; font-weight: 600; color: var(--text-dim); }
.sim-header .accent { color: var(--accent); }
.status {
    font-size: 12px; font-family: var(--mono); padding: 4px 10px; border-radius: 20px;
    background: var(--surface); border: 1px solid var(--border); color: var(--text-dim);
}
.status.running { color: var(--green); border-color: rgba(74, 222, 128, 0.3); }
.board {
    background: var(--pcb); border: 2px solid var(--pcb-border); border-radius: var(--radius);
    padding: 24px 20px; display: flex; flex-direction: column; align-items: center;
    gap: 20px; margin-bottom: 16px;
}
.board-label {
    font-family: var(--mono); font-size: 10px; font-weight: 700;
    color: rgba(255,255,255,0.25); letter-spacing: 0.1em; text-transform: uppercase;
}
.component-group { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
.component-label {
    font-size: 9px; font-weight: 600; text-transform: uppercase;
    letter-spacing: 0.1em; color: rgba(255,255,255,0.3);
}
.audio-controls {
    display: flex; gap: 12px; align-items: center; justify-content: center;
}
.audio-btn {
    appearance: none; border: 2px solid var(--accent); background: transparent;
    color: var(--accent); font-family: var(--mono); font-size: 12px; font-weight: 700;
    padding: 10px 20px; border-radius: 8px; cursor: pointer;
    transition: all 0.15s ease;
}
.audio-btn:hover { background: rgba(108,140,255,0.15); }
.audio-btn.active { background: var(--accent); color: #fff; }
.audio-btn.danger { border-color: var(--red); color: var(--red); }
.audio-btn.danger:hover { background: rgba(248,113,113,0.15); }
.audio-btn.danger.active { background: var(--red); color: #fff; }
.vu-meter {
    width: 100%; height: 24px; background: var(--surface); border-radius: 4px;
    overflow: hidden; position: relative;
}
.vu-bar {
    height: 100%; background: var(--green); border-radius: 4px;
    transition: width 0.05s ease; width: 0%;
}
.vu-label {
    position: absolute; top: 50%; left: 8px; transform: translateY(-50%);
    font-family: var(--mono); font-size: 9px; color: var(--text-dim);
}
.log-panel {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); overflow: hidden;
}
.log-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 16px; border-bottom: 1px solid var(--border);
    font-size: 12px; font-weight: 600; color: var(--text-dim);
    text-transform: uppercase; letter-spacing: 0.05em;
}
.log-actions { display: flex; gap: 6px; }
.log-btn {
    appearance: none; border: 1px solid var(--border); background: transparent;
    color: var(--text-dim); font-size: 11px; padding: 2px 8px; border-radius: 4px; cursor: pointer;
}
.log-btn:hover { border-color: var(--accent); color: var(--accent); }
.log-content {
    padding: 12px 16px; font-family: var(--mono); font-size: 12px; line-height: 1.6;
    max-height: 250px; overflow-y: auto; color: var(--text-dim);
}
.log-content .log-line { white-space: pre; }
.log-content .log-line.info { color: var(--green); }
.log-content .log-line.error { color: var(--red); }
.log-content .log-line.warn { color: var(--yellow); }
.rec-btn {
    appearance: none; border: none; background: #c0392b; color: white;
    font-family: var(--mono); font-size: 10px; font-weight: 700;
    padding: 4px 10px; border-radius: 20px; cursor: pointer; letter-spacing: 0.05em;
}
.rec-btn:hover { background: #e74c3c; }
.rec-btn.recording { background: #e74c3c; animation: rec-pulse 1s infinite; }
@keyframes rec-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.6; } }
.rec-status { font-family: var(--mono); font-size: 10px; color: var(--text-dim); }
    </style>
</head>
<body>
    <div class="sim-container">
        <header class="sim-header">
            <h1>embed-zig <span class="accent">WebSim</span></h1>
            <div style="display:flex;align-items:center;gap:8px;">
                <span class="status" id="status">Loading...</span>
                <button class="rec-btn" id="recBtn">REC</button>
                <span class="rec-status" id="recStatus"></span>
            </div>
        </header>

        <div class="board">
            <div class="board-label">AEC Test — Korvo-2 V3 (Native)</div>

            <div class="component-group">
                <div class="component-label">Microphone (WebRTC AEC)</div>
                <div class="audio-controls">
                    <button class="audio-btn" id="micBtn">MIC OFF</button>
                </div>
                <div class="vu-meter">
                    <div class="vu-bar" id="micLevel"></div>
                    <span class="vu-label">Mic Input</span>
                </div>
            </div>

            <div class="component-group">
                <div class="component-label">Speaker Output</div>
                <div class="vu-meter">
                    <div class="vu-bar" id="speakerLevel" style="background:var(--accent);"></div>
                    <span class="vu-label">Speaker Out</span>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <div class="log-header">
                <span>Console</span>
                <div class="log-actions">
                    <button class="log-btn" id="logCopy">Copy</button>
                    <button class="log-btn" id="logClear">Clear</button>
                </div>
            </div>
            <div class="log-content" id="logContent"></div>
        </div>
    </div>

    <script>
/* WebSim Native JS — AEC test */
const WebSim = (() => {
    let running = false;

    function updateLog(state) {
        if (!state.log_dirty) return;
        const content = document.getElementById('logContent');
        if (!content || !state.logs) return;
        content.innerHTML = state.logs.map(l => {
            let c = 'log-line';
            if (l.startsWith('[INFO]')) c += ' info';
            else if (l.startsWith('[ERROR]')) c += ' error';
            else if (l.startsWith('[WARN]')) c += ' warn';
            return '<div class="' + c + '">' + l.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</div>';
        }).join('');
        content.scrollTop = content.scrollHeight;
    }

    function updateVU(state) {
        const micEl = document.getElementById('micLevel');
        const spkEl = document.getElementById('speakerLevel');
        if (spkEl && state.audio_out_avail !== undefined) {
            const pct = Math.min(100, (state.audio_out_avail / 1000) * 100);
            spkEl.style.width = pct + '%';
        }
    }

    /* Mic capture via Web Audio API with AEC */
    let audioCtx = null, micStream = null, micNode = null;

    async function startMic() {
        try {
            audioCtx = new AudioContext({ sampleRate: 16000 });

            /* Speaker playback node (pulls from Zig ring buffer) */
            const spkNode = audioCtx.createScriptProcessor(1024, 0, 1);
            spkNode.onaudioprocess = async (e) => {
                /* TODO: pull speaker samples from Zig via binding */
                e.outputBuffer.getChannelData(0).fill(0);
            };
            spkNode.connect(audioCtx.destination);

            /* Mic capture with AEC */
            micStream = await navigator.mediaDevices.getUserMedia({
                audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true,
                         noiseSuppression: true, autoGainControl: true }
            });
            const source = audioCtx.createMediaStreamSource(micStream);
            micNode = audioCtx.createScriptProcessor(256, 1, 1);
            micNode.onaudioprocess = (e) => {
                const input = e.inputBuffer.getChannelData(0);
                for (let i = 0; i < input.length; i++) {
                    const sample = Math.max(-32768, Math.min(32767, Math.round(input[i] * 32768)));
                    zigPushAudioInSample(sample);
                }
                /* Update mic VU meter */
                const micEl = document.getElementById('micLevel');
                if (micEl) {
                    let peak = 0;
                    for (let i = 0; i < input.length; i++) peak = Math.max(peak, Math.abs(input[i]));
                    micEl.style.width = (peak * 100) + '%';
                }
            };
            source.connect(micNode);
            micNode.connect(audioCtx.destination);

            return true;
        } catch(e) {
            console.warn('Mic access failed:', e);
            /* Show error in log panel */
            const logEl = document.getElementById('logContent');
            if (logEl) {
                logEl.innerHTML += '<div class="log-line error">[JS] Mic error: ' + e.name + ': ' + e.message + '</div>';
                logEl.scrollTop = logEl.scrollHeight;
            }
            return false;
        }
    }

    function stopMic() {
        if (micNode) { micNode.disconnect(); micNode = null; }
        if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
        if (audioCtx) { audioCtx.close(); audioCtx = null; }
    }

    function initInput() {
        const micBtn = document.getElementById('micBtn');
        if (micBtn) {
            micBtn.addEventListener('click', async () => {
                if (micStream) {
                    stopMic();
                    micBtn.textContent = 'MIC OFF';
                    micBtn.classList.remove('active');
                } else {
                    micBtn.textContent = 'Starting...';
                    const ok = await startMic();
                    if (ok) {
                        micBtn.textContent = 'MIC ON';
                        micBtn.classList.add('active');
                    } else {
                        micBtn.textContent = 'MIC FAILED';
                        setTimeout(() => { micBtn.textContent = 'MIC OFF'; }, 2000);
                    }
                }
            });
        }
        const logClear = document.getElementById('logClear');
        const logContent = document.getElementById('logContent');
        if (logClear && logContent) logClear.addEventListener('click', () => { logContent.innerHTML = ''; });
        const logCopy = document.getElementById('logCopy');
        if (logCopy && logContent) logCopy.addEventListener('click', () => {
            const ta = document.createElement('textarea');
            ta.value = logContent.innerText;
            ta.style.position = 'fixed'; ta.style.left = '-9999px';
            document.body.appendChild(ta); ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            logCopy.textContent = 'Copied!'; setTimeout(() => { logCopy.textContent = 'Copy'; }, 1000);
        });
    }

    async function frame() {
        if (!running) return;
        try {
            const state = await zigGetState();
            if (state) { updateLog(state); updateVU(state); }
        } catch(e) {}
        requestAnimationFrame(frame);
    }

    return {
        start() {
            initInput();
            running = true;
            const status = document.getElementById('status');
            if (status) { status.textContent = 'Running'; status.classList.add('running'); }
            requestAnimationFrame(frame);
        }
    };
})();

WebSim.start();

/* Recording (same as adc_button) */
(function() {
    const recBtn = document.getElementById('recBtn');
    const recStatus = document.getElementById('recStatus');
    if (!recBtn) return;
    let isRec = false, recTimer = null, recStart = 0;
    function updateTimer() { if (!isRec) return; recStatus.textContent = ((Date.now()-recStart)/1000).toFixed(1)+'s'; requestAnimationFrame(updateTimer); }
    recBtn.addEventListener('click', async () => {
        if (!isRec) {
            try { await zigStartRecording(); isRec = true; recStart = Date.now(); recBtn.textContent = 'STOP'; recBtn.classList.add('recording'); updateTimer(); } catch(e) { recStatus.textContent = 'Error'; }
        } else {
            isRec = false; try { await zigStopRecording(); recStatus.textContent = 'Copied!'; setTimeout(() => { recStatus.textContent = ''; }, 3000); } catch(e) {}
            recBtn.textContent = 'REC'; recBtn.classList.remove('recording');
        }
    });
})();
    </script>
</body>
</html>
